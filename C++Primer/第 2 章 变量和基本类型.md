* char 和 signed char并不相同，在算术表达式尽量不用char和bool，因为char在不同机器上可能是有符号和无符号的两种情况。
* 给无符号数赋值一个超出范围的数，结果是该数对**无符号类型表示数字总数**取模后的**余数**（eg：0-255就是取模256）
* 给有符号类型赋一个超过范围的值，结果**未定义**
* 算术表达式有int和无符号类型时，int会被转换成无符号类型，**有符号类型和无符号**类型混用会**都变成无符号**

> 对象：具有某种数据类型的内存空间

* 默认情况下，定义于任何函数体之外的变量被初始化为0，函数体内部的内置类型变量将**不被初始化**

如果只声明不定义，用extern，且不要显示初始化变量。extern如果包含初始值就不是声明，就变成了定义！

* 允许在**内层作用域**重新定义外层作用域已有的名字，但不宜使用
* **引用必须初始化，一旦初始化完成，无法令引用重新绑定到另一个对象**
* 引用不是对象，没有地址，所以不能定义指向引用的指针

### const限定符

1. const对象一旦创建后其值就不能再改变，所以const对象**必须初始化**。

2. 默认状态下，const对象仅在文件内有效，多个文件出现同名const对象，相当于在不同文件分别定义了独立的变量。

3. 想要在一个文件定义const，**多个文件中声明并使用它**，则不管**声明还是定义都添加extern关键字**

4. 允许const限定的常量引用/指向常量的指针绑定或指向非常量的对象，不能通过常量指针和引用去改变非常量的值，但可以通过其他途径改变。

5. 常量指针不变的是指针本身的值而非指向的那个值。可以通过指针修改指向的值。

   > 顶层const：指针本身是个常量，**不能改地址**	eg：int * const p1 = &i p1不能改
   >
   > 底层const：指针所指的对象是个常量（它自认为的），**不能改地址指向的变量** eg:const int *p2 = &ci p2可以改，不能 *p2改ci 

### 处理类型

* 类型别名

  using si = sale_item si是sale_item别名

  typedef double wages；

  typedef wages base ， *p //wages和base都是double型，p是double * 型

  **指针和类型别名**

  > typedef char *pstring;
  >
  > **const pstring cstr = 0; // cstr是指向char的常量指针，const修饰的是pstring，而pstring是指向char的指针，所以const pstring就是指向char的常量指针**
  >
  > **const char *cstr = 0; //cstr是对const pstring cstr的错误理解**
  >
  > const pstring *ps; // ps是一个指针，它的对象是指向char 的常量指针

​		**不可以把类型别名替换成本来的样子理解！！！**

* auto类型

  1. 当引用被用作初始值，真正参与初始化的是引用对象的值，所以**编译器以引用对象的类型作为auto的类型**
  2. auto类型会**忽略顶层const**，保留底层const。如果希望auto是顶层const，要明确写出
  3. 设置auto引用，初始值中的顶层常量属性仍然保留

* decltype类型

  1. 从表达式中的类型推断要定义的变量类型，包括顶层const和引用在内

  2. 变量是一种可以作为赋值语句左值的特殊表达式，所以这也的decltype就会得到引用：

     decltype（(i)）d;//错误，d是int & ，必须初始化

     decltype（i）e；//正确，e是一个未初始化的int

     **所以双层括号永远是引用**

### 自定义数据结构

struct sales_data{

​	int a;

​	......

};

c++11可以为类内成语提供一个**类内初始值**

* 头文件通常包含那些只能被定义一次的实体

预处理器概述：确保头文件多次包含还能安全工作的技术通常是**预处理器**

* 头文件保护符：

  #define：设定预处理变量

  #ifdefine：检查预处理变量是否被定义，有为真

  #ifndefine：与上者相反

  #endif：前两个检查为真，执行后续操作到遇到endif为止

  `#ifdef SALE_DATA`

  `#define SALE_DATA `

  `.....`

  `#endif`

  

  

  

  

​		

