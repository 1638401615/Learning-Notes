## RESTful API

产生需求：客户端种类多元化，客户端和服务端通信需要一个**统一、结构清晰、符合标准、易于理解、扩展方便的接口规范**

* restful是一种风格而非标准

* 这个风格有如下特征：

  * **以资源为基础**

  * **统一接口**：对资源的操作包括**获取、创建、修改和删除**，这些操作正好对应HTTP协议提供的**GET、POST、PUT和DELETE**方法。

  * **URI指向资源**：URI包括了URL和URN，更多时候代指URL

    > URL vs URN
    >
    > * URL是统一资源定位符，定义了资源的位置和访问方式
    > * URN是统一资源名称，指定一个资源的名称和标识，但不定义如何访问该资源

  * **无状态**：服务器不能保存客户端数据。每次客户端发请求需要包含必须的所有状态信息，会话信息由客户端保存，服务端根据这些状态信息来处理请求。

### REST架构限制条件

* 客户端-服务端：更专注客户端和服务端分离，服务端独立，更好地服务前端、安卓、IOS等客户端设备
* 无状态
* 可缓存性：服务端需回复是否可以缓存以让客户端甄别是否缓存提高效率。
* 统一接口
* 分层系统：客户端无法直接知道连接到的是终端还是中间设备，分层允许你灵活部署服务端项目
* 按需代码（可选）



### HTTP动词

```text
GET /collection：从服务器查询资源的列表（数组）
GET /collection/resource：从服务器查询单个资源
POST /collection：在服务器创建新的资源
PUT /collection/resource：更新服务器资源
DELETE /collection/resource：从服务器删除资源
```

* GET请求会把参数附加在URL后面
* POST请求用于新增一个资源，**请求参数在请求体**，大小无限制
* PUT请求用于更新资源，侧重**数据的修改**
* DELETE请求用来删除资源

在非restful中从请求方式上无从得知API具体是干嘛的，而且URL上会有操作的动词表示API动作

在RESTful的API要求**URL上都以名词出现**，从请求方式上就能看出想要进行的操作。

![img](https://pic1.zhimg.com/80/v2-46b880b82c5cec18708506f7a34547b4_1440w.webp)

> 安全性和幂等性
>
> 安全性：HTTP方法不会改变资源状态，即读操作是安全的，写操作是不安全的
>
> 幂等性：一次操作和多次操作的最终效果相同，客户端重复调用也只会返回同一个结果
>
> ![img](https://pic1.zhimg.com/80/v2-3d59c2beffb51d40d7c05fcf83ed372c_1440w.webp)
>
> PUT vs PATCH
>
> * PUT用于更新**整个资源**，它是幂等的
> * PATCH主要用于**执行某项操作并更新资源的某些字段**，不一定幂等

### 状态码和返回数据

* 1xx：相关信息
* 2xx：操作成功
* 3xx：重定向
* 4xx：客户端错误
* 5xx：服务器错误

>200 `OK - [GET]`：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
>201 `CREATED - [POST/PUT/PATCH]`：用户新建或修改数据成功。
>202 `Accepted - [*]`：表示一个请求已经进入后台排队（异步任务）
>204 `NO CONTENT - [DELETE]`：用户删除数据成功。
>
>301 `Moved Permanently`：请求的资源已被永久移动到新的URI，并在响应中给出了新的URI。客户端应该使用新的URI来访问资源。
>302 `Found`：请求的资源已被临时移动到新的URI，并在响应中给出了新的URI。客户端可以继续使用原来的URI来访问资源。
>304 `Not Modified`：请求的资源没有被修改，服务器不会返回任何内容。客户端可以继续使用缓存中的资源。
>
>400 `INVALID REQUEST - [POST/PUT/PATCH]`：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
>401 `Unauthorized - [*]`：表示用户没有权限（令牌、用户名、密码错误）。
>403 `Forbidden - [*]` 表示用户得到授权（与401错误相对），但是访问是被禁止的。
>404 `NOT FOUND - [*]`：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
>406 `Not Acceptable - [GET]`：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
>410 `Gone -[GET]`：用户请求的资源被永久删除，且不会再得到的。
>422 `Unprocesable entity - [POST/PUT/PATCH]` 当创建一个对象时，发生一个验证错误。
>500 `INTERNAL SERVER ERROR - [*]`：服务器发生错误，用户将无法判断发出的请求是否成功。
>
>503 `Service Unavailable`- 服务端当前无法处理请求

### 缺点

* 操作方式繁琐
* 有些浏览器对GET，POST之外的请求支持不友好，需要额外处理
* 过分强调资源，而实际业务API可能有各种需求比较复杂，单单使用资源的增删改查可能并不能有效满足使用需求，强行使用RESTful风格API只会增加开发难度和成本。





## Redis

> Redis能做什么？
>
> * 用sortSet轻松实现**排行榜**
> * **计算器/限速器**：利用 Redis 中原子性的自增操作
> * **好友关系**：利用集合命令，交并补轻松实现共同好友、共同爱好什么的
> * **简单消息队列**：除了 Redis 自身的**发布/订阅模式**，我们也可以利用 **List** 来实现一个队列机制，比如到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成**异步解耦**；
> * **Session共享**：以 PHP 为例，默认 Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。
>
> Redis不能做什么？
>
> * 用redis存用户信息，虽然能持久化，但是redis**持久化方案不能保证数据的绝对落地**，**频繁持久化**也会增大redis服务压力，导致性能下降
> * **数据量太大、数据访问频率太低**的业务都不适合用redis，数据太大增加成本，访问频率太低，保存在内存纯属浪费
>
> 
>
> :star: Redis有什么优点？这些功能其他东西也能做
>
> * 速度快，完全基于内存，使用 C 语言实现，网络层使用 epoll 解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件;
>
>   **注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理。**
>
> * 丰富数据类型，有八种，主要用**String、Hash、List、Set、SortSet**这五种

### Redis数据类型

键的类型只能是字符串，值可以有常见的五种类型。

* string
* Hash
* List：拿来实现临时队列用的
* Set：**string类型的无序集合**，集合通过哈希表实现，所以增删改查复杂度都是O(1)
* zset：和set一样是string，且不允许重复，不同的是每个元素都关联一个**double的分数**，利用该分数进行从小到大的排序。zset成员唯一，分数可以重复

### Redis持久化

持久化就是**内存数据写到磁盘**，防止服务器宕机内存数据丢失。

Redis提供两种持久化：**RDB和AOF**

* Redis DataBase

  RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式

  功能核心函数**rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）**两个函数

  RDB三种触发机制：

  1. save：该命令**阻塞当前Redis服务器**，执行save期间Redis不能处理其他命令，一般不可取。执行完成时候如果存在老的RDB文件，就把**新的替代掉旧的**

     <img src="https://pic1.zhimg.com/80/v2-1ee1d87331d52392c605ab0032821ed4_1440w.webp" alt="img" style="zoom: 67%;" />

  2. bgsave：Redis进程执行fork**创建子进程**，**持久化过程由子进程负责**，完成后自动结束。阻塞只发生在fork阶段。

     <img src="https://pic1.zhimg.com/80/v2-a52f25362a0a3f5b1eca5687f113791c_1440w.webp" alt="img" style="zoom:67%;" />

  3. 自动触发：通过配置文件`redis.conf`完成。比如`save m n`。表示m秒内数据集存在n次修改时，自动触发bgsave。

  优势：

  * 文件紧凑，全量备份，适合备份和灾难恢复。
  * bgsave使得主进程无需任何磁盘IO操作
  * RDB恢复大数据集速度比AOF快

  劣势：

  * 快照持久化的时候子进程会有父进程的内存数据，但是父进程修改内存子进程无法反应，所以在**快照持久化期间修改的数据不会被保存**，可能丢失数据。
  * 全量备份太耗时。

* Append-only File

  每当有一个写命令过来时，就直接保存在我们的AOF文件中。

  <img src="https://pic2.zhimg.com/80/v2-30d0736f190de7ae32fa472d7eae7021_1440w.webp" alt="img" style="zoom:67%;" />

  为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会**fork出一条新进程来将文件重写**。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式**重写了一个新的aof文件**，这点和快照有点类似。

  <img src="https://pic2.zhimg.com/80/v2-0676f505f05e7b8ea4b2f02f61389a3d_1440w.webp" alt="img" style="zoom:67%;" />

  三种触发机制：

  * always：每修改同步，同步持久化，性能差但是数据完整性好
  * everysec：异步操作，每秒记录，有一秒宕机，数据丢失
  * 不同no：从不同步

  优势：

  * AOF**更好保存数据不丢失**，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据
  * **没有磁盘寻址开销，写入性能搞，文件不易破损**
  * 后台重写，不影响客户端读写
  * AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复

  劣势：

  * 同一份数据，AOF日志比RDB快照更大
  * AOF开启后支持的写QPS比RDB的低，因为AOF一般会配置成每秒fsync一次日志文件

  <img src="https://pic2.zhimg.com/80/v2-25a35f6536ebe44fb3af8e5bb60eb775_1440w.webp" alt="img" style="zoom:67%;" />

  每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作

  aof写入保存：

  WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件

  SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。

* **比较**：

  1、aof文件比rdb更新频率高，**优先使用aof还原数据**，数据完整性更好。

  2、**aof比rdb更安全也更大**

  3、rdb性能比aof好

  4、如果两个都配了优先加载AOF

### Reids通讯协议RESP

RESP 的特点：实现简单、快速解析、可读性好

>For Simple Strings the first byte of the reply is "+" 回复
>
>For Errors the first byte of the reply is "-" 错误
>
>For Integers the first byte of the reply is ":" 整数
>
>For Bulk Strings the first byte of the reply is "$" 字符串
>
>For Arrays the first byte of the reply is "*" 数组

### Redis架构模式

* 单机版

  简单，此外一无是处（内存容量有限、处理能力有限、无法高可用）

* 主从复制

  降低master的读压力转交从库，但是没解决master的写压力，仍无法保证高可用

  ![img](https://www.redis.com.cn/images/riq4.png)

* 哨兵

  <img src="https://www.redis.com.cn/images/riq5.png" alt="img" style="zoom: 80%;" />

  sentinel在分布式系统中监控Redis主从服务器，主服务器下线自动进行故障转移

  特性：

  监控（Monitoring）： Sentinel 会不断地**检查**你的主服务器和从服务器是否运作正常。

  提醒（Notification）： 当被监控的**某个 Redis 服务器出现问题**时， Sentinel 可以通过 API 向管理员或者其他应用程序**发送通知**。

  自动故障迁移（Automatic failover）： 当一个**主服务器不能正常工作**时， Sentinel 会开始一次**自动故障迁移**操作。

  特点：

  保障高可用，监控各个节点，自动故障转移。

  缺点是主从模式切换需要时间丢诗句，没解决master的写压力

* 集群（proxy型）

  <img src="https://www.redis.com.cn/images/riq6.png" alt="img" style="zoom:80%;" />

  支持多种hash算法，支持失败节点自动删除，后端分片对业务透明。

  增加proxy，需要维护其高可用，failover要自己实现。

* 集群（直线型）

  <img src="https://www.redis.com.cn/images/riq7.png" alt="img" style="zoom:80%;" />

  无中心，高可用，可扩展，故障自动failover，投票完成slave到master。

  资源隔离性差，容易互相影响。

  数据异步复制，不保证强一致性。

### Redis分布式锁

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。

>**如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？**
>
>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！

### Redis缓存

**缓存穿透**：缓存和数据库中都没有的数据

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

如何避免？

1：对查询结果为**空的情况也进行缓存**，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。

2：对**一定不存在的key**进行**过滤**（参数校验，布隆过滤器）。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。

**缓存雪崩**

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

如何避免？

1：在缓存失效后，通过加锁或者队列来**控制**读数据库写缓存的**线程数量**。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

2：做**二级缓存**，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

3：不同的key，设置不同的过期时间，让缓存**失效的时间点尽量均匀**。

**缓存击穿**：缓存中没有但是数据库中有的数据（一般是缓存到期）

解决方案：

1. 设置热点数据永不过期
2. 接口限流与熔断、降级
3. **加互斥锁**访问数据库数据
4. 缓存失效时，只让一个线程去查询数据库并更新缓存，其他线程等待或者重试

http://jasontec.cn/articles/2019/12/20/1576826633007.html

## Raft算法

- Raft算法是一种**分布式一致性算法**，用于管理多副本状态机的日志复制。它将一致性问题分解为三个子问题：**领导选举、日志同步和安全性。**
- **领导选举**是指在集群中选出一个唯一的领导者节点，负责接收客户端的请求，并向其他跟随者节点发送**心跳消息**。如果跟随者节点在一定时间内没有收到心跳消息，就会认为领导者节点失效，然后发起**新的选举**。
- **日志同步**是指领导者节点将客户端的请求转化为日志条目，然后并行地向其他跟随者节点发送日志复制请求。当日志条目被复制到**大多数节点**上时，领导者节点将该日志条目应用到自己的状态机，并通知其他跟随者节点提交该日志条目。
- **安全性**是指保证集群中的**所有节点的日志一致性和正确性**。Raft算法通过一些限制和检查来实现安全性，例如只有拥有最新的已提交日志条目的节点才能成为领导者，领导者只能提交当前任期的日志条目，跟随者只能接受和自己日志匹配的日志条目等。

Raft算法满足CAP的一致性（C）和可用性（A）两点，但牺牲了分区容错性（P）。

- 一致性（C）是指集群中的所有节点在同一时刻看到的数据是一致的。Raft算法通过领导选举、日志同步和安全性机制来保证集群中的所有节点的日志一致性，从而实现**数据一致性**。
- 可用性（A）是指集群中的任意节点在任意时刻都能够响应客户端的请求。Raft算法通过领导者节点来接收和处理客户端的请求，并向其他跟随者节点发送心跳消息来维持自己的领导地位。如果领导者节点失效，集群中的其他节点会自动发起新的选举来**选出新的领导者节点**，从而保证**集群的可用性**。
- 分区容错性（P）是指集群中的部分节点因为网络故障而无法通信时，集群仍然能够正常工作。**Raft算法为了保证一致性和可用性，要求集群中的大多数节点能够正常通信**。如果出现网络分区，导致集群中没有大多数节点能够通信，那么Raft算法就无法进行领导选举和日志同步，从而无法提供服务。因此，Raft算法牺牲了分区容错性。

> Raft算法要求大多数节点能够通信的原因是：
>
> - Raft算法是基于多数派原则来实现一致性的，即只有当一个日志条目被复制到大多数节点上时，才能被认为是已提交的，从而可以应用到状态机上。如果大多数节点不能通信，那么就无法达成一致性。
> - Raft算法是基于心跳机制来触发领导选举的，即领导者节点会周期性地向跟随者节点发送心跳消息来维持自己的领导地位。如果跟随者节点在一定时间内没有收到心跳消息，就会认为领导者节点失效，然后发起新的选举。如果大多数节点不能通信，那么就无法选出新的领导者节点。