## TCP和UDP

[一文搞定 UDP 和 TCP 高频面试题！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/108822858)

* 传输层提供了**进程间的逻辑通信**，网络层只负责把分组发送到目的主机，真正通信的是主机中的进程。
* TCP和UDP的特点：
  * UDP：无连接，尽可能交付，没拥塞控制，面向报文，支持一对一，一对多多对一和多对多通信
  * TCP：面向连接，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，每条TCP只能是点对点的（一对一）
* **TCP首部长度20-60字节（20字节固定首部），UDP首部只有8个字节**

* TCP的确认号是希望收到的下一个报文段的序号

### TCP的三次握手

1. client向server发送连接请求**SYN**报文，SYN=1，ACK=0，选择初始序号x（客户机进入SYN_SEND状态）
2. 服务器接收到请求报文，如果同意建立连接，发回**SYNACK**报文，SYN=1，ACK=1，确认号x+1,同时选择初始序号y（服务器进入SYN_RECV状态）
3. 客户端接收到服务器的连接确认报文后，发送**ACK for SYNACK**，确认号y+1，序号x+1，服务器收到后连接建立（客户端和服务端都进入ESTABLISH状态）

> 为什么要第三次握手？
>
> 1. 防止失效连接请求到达服务器导致服务器错误打开连接
> 2. 服务端和客户端都能保证双方的收发能力正常

### TCP的四次挥手

1. 客户端发送**FIN**，包含一个ACK表示确认对方最近一次发过来的数据，包含一个当前序列号K
2. 服务端把K+1作为ACK序列号，发回**对FIN的ACK报文**，上层应用程序会被告知另一端发起了关闭操作，通常将引起应用程序发起自己的关闭操作
3. 服务端发起自己的**FIN**，ACK=K+1，Seq=L
4. 客户端确认，进入**TIME-WAIT**状态，等待2 MSL（最大报文存活时间）后释放连接，ACK=L+1

> 为什么要四次挥手关闭连接？
>
> * 服务端收到客户端FIN，说明客户端想要断开连接，但是服务端仍有数据，等到发送完所有数据，才会发送FIN关闭此方向的连接，连接接收方发送ACK确认关闭连接。
> * **接收到对方的FIN报文，只能表示对方不再发送数据了但是还能接收数据**
>
> 接收到FIN只能返回ACK，不能返回FIN？
>
> * 因为结束数据传输的指令是上层应用层给出的
>
> 为什么需要一个TIME-WAIT状态？（客户端收到服务器端的FIN进入此状态）
>
> * 确保最后一个确认报文能到达，如果服务端没收到客户端发来的确认报文，就会重新发送FIN报文，所以需要客户端等待一段时间
> * 让本连接持续时间内产生的所有报文都从网络中消失，使得下一个连接不会出现旧的连接请求报文

