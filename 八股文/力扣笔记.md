# 滑动窗口

> 关键词：**最大/最小连续，子数组，子字符串**
>
> 解法关键：左右边界双指针

## 剑指 Offer II 016. 不含重复字符的最长子字符串

* 设定左右窗口边界，利用unordered_set作为哈希集存储字母是否在window中，每个左边界都尽力移动右边界去寻找最大字符串，然后删除左边界，左指针右移一格继续查询。

## 209. 长度最小的子数组

* 同上，但是这次维护的是一个双端队列，为每个左边界寻找满足条件的右边界，唯一区别是从子数组中pop元素的时候要记得修改子数组之和sum的数值。

## 2024. 考试的最大困扰度

* 仍是维护左右边界，维护量变为数量少的那个字符的数量不能超过k个，为了简单，直接限定为T或者F，然后取两个函数返回的最大值。

## 424. 替换后的最长重复字符

* 维护一个最多重复字符，这样用长度减去最多重复字符就是需要修改的字符数
* 右指针不断右移，左指针只在子字符串不满足条件的时候左移，保证了right-left是最长的子字符串长度

## 1695. 删除子数组的最大得分

* 维护一个子数组之和变量和哈希表，计算是否出现重复子元素，否则不断右移右指针，有重复元素就左移左指针直至子数组合法

## 2134. 最少交换次数来组合所有的 1 II

* 换个思路，计算区间中所有的0的个数，以数组所有的1的个数作为长度。左右指针同时右移，计算不同位置下所需要交换的0个数，取最小值

## 1208. 尽可能使字符串相等

* 套模板，左指针遍历，对每一个左指针寻找最大右边界，然后超出maxCost再左移左指针
* 这里需要注意边界问题！有可能right == n但是cost在maxCost范围内，这个时候的长度应该是right - left，其他情况才是right处于右边界右边一个，需要用right - left - 1来代表长度

# 二分查找

关键词：**有序数组，无重复元素**，循环不变量原则，明确区间边界定义

两种写法:

* [left, right): **左闭右开**区间，循环判定条件为`left < right`，如果`nums[middle] > target`则把右边界改为`middle`，因为右边界是开的，不会再扫描到middle，左边界`nums[middle] < target`则需要`middle + 1`来保证middle不会再被扫描到。

  ```cpp
  while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
              int middle = left + ((right - left) >> 1);
              if (nums[middle] > target) {
                  right = middle; // target 在左区间，在[left, middle)中
              } else if (nums[middle] < target) {
                  left = middle + 1; // target 在右区间，在[middle + 1, right)中
              } else { // nums[middle] == target
                  return middle; // 数组中找到目标值，直接返回下标
              }
          }
  ```

* [left, right]：**左闭右边闭**区间，循环条件为`left <= right`，因为此时`left == right`有意义。此时因为是左右闭合，所以扫描过middle处元素后，不满足条件无论是左边界还是右边界都不能是middle才能保证middle处的元素不被扫描到。

  ```cpp
   while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
              int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
              if (nums[middle] > target) {
                  right = middle - 1; // target 在左区间，所以[left, middle - 1]
              } else if (nums[middle] < target) {
                  left = middle + 1; // target 在右区间，所以[middle + 1, right]
              } else { // nums[middle] == target
                  return middle; // 数组中找到目标值，直接返回下标
              }
          }
  ```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

* 确定好如何寻找左右边界，利用一个bool变量将左右边界的二分查找集成在一个函数实现

* 注意答案未被赋值的特殊情况，以此确定是否正确找出边界

* 利用以下情况更新左边界：

  ```cpp
  if (nums[middle] >= target) { // 寻找左边界，nums[middle] == target的时候更新right
                  right = middle - 1;
                  leftBorder = right;
              } 
  ```

  更新右边界反之：

  ```cpp
  if (nums[middle] > target) {
                  right = middle - 1;
              } else { // 寻找右边界，nums[middle] == target的时候更新left
                  left = middle + 1;
                  rightBorder = left;
              }
  ```

   **此处的左右边界均为不包含target的下标！！！**

# 双指针

## [27. 移除元素](https://leetcode.cn/problems/remove-element/description/)

* 利用快慢指针处理，遍历过去把不是要移除元素的快指针所在的元素赋值给慢指针，然后慢指针自增。

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

* 快指针比慢指针多走n+1步，然后共同移动至快指针到达null。此时慢指针在倒数第N个节点前一个节点。

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

* 利用快慢指针一前一后，不断调换next的方向，迭代整个链表后实现反转

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

* 利用快慢指针，快指针一次走两步。相遇则说明有环。然后利用数学原理推导入环位置。
* 一个从头节点出发，一个从相遇节点出发，他们二者同时移动，相遇节点即为环入口节点位置。

# 哈希表

关键词：重复出现（一般为隐含条件，重复出现说明无限循环之类的），不重复集合
