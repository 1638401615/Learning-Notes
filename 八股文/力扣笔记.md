# 滑动窗口

> 关键词：**最大/最小连续，子数组，子字符串**
>
> 解法关键：左右边界双指针

## 剑指 Offer II 016. 不含重复字符的最长子字符串

* 设定左右窗口边界，利用unordered_set作为哈希集存储字母是否在window中，每个左边界都尽力移动右边界去寻找最大字符串，然后删除左边界，左指针右移一格继续查询。

## 209. 长度最小的子数组

* 同上，但是这次维护的是一个双端队列，为每个左边界寻找满足条件的右边界，唯一区别是从子数组中pop元素的时候要记得修改子数组之和sum的数值。

## 2024. 考试的最大困扰度

* 仍是维护左右边界，维护量变为数量少的那个字符的数量不能超过k个，为了简单，直接限定为T或者F，然后取两个函数返回的最大值。

## 424. 替换后的最长重复字符

* 维护一个最多重复字符，这样用长度减去最多重复字符就是需要修改的字符数
* 右指针不断右移，左指针只在子字符串不满足条件的时候左移，保证了right-left是最长的子字符串长度

## 1695. 删除子数组的最大得分

* 维护一个子数组之和变量和哈希表，计算是否出现重复子元素，否则不断右移右指针，有重复元素就左移左指针直至子数组合法

## 2134. 最少交换次数来组合所有的 1 II

* 换个思路，计算区间中所有的0的个数，以数组所有的1的个数作为长度。左右指针同时右移，计算不同位置下所需要交换的0个数，取最小值

## 1208. 尽可能使字符串相等

* 套模板，左指针遍历，对每一个左指针寻找最大右边界，然后超出maxCost再左移左指针
* 这里需要注意边界问题！有可能right == n但是cost在maxCost范围内，这个时候的长度应该是right - left，其他情况才是right处于右边界右边一个，需要用right - left - 1来代表长度

# 二分查找

关键词：**有序数组，无重复元素**，循环不变量原则，明确区间边界定义

两种写法:

* [left, right): **左闭右开**区间，循环判定条件为`left < right`，如果`nums[middle] > target`则把右边界改为`middle`，因为右边界是开的，不会再扫描到middle，左边界`nums[middle] < target`则需要`middle + 1`来保证middle不会再被扫描到。

  ```cpp
  while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
              int middle = left + ((right - left) >> 1);
              if (nums[middle] > target) {
                  right = middle; // target 在左区间，在[left, middle)中
              } else if (nums[middle] < target) {
                  left = middle + 1; // target 在右区间，在[middle + 1, right)中
              } else { // nums[middle] == target
                  return middle; // 数组中找到目标值，直接返回下标
              }
          }
  ```

* [left, right]：**左闭右边闭**区间，循环条件为`left <= right`，因为此时`left == right`有意义。此时因为是左右闭合，所以扫描过middle处元素后，不满足条件无论是左边界还是右边界都不能是middle才能保证middle处的元素不被扫描到。

  ```cpp
   while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
              int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
              if (nums[middle] > target) {
                  right = middle - 1; // target 在左区间，所以[left, middle - 1]
              } else if (nums[middle] < target) {
                  left = middle + 1; // target 在右区间，所以[middle + 1, right]
              } else { // nums[middle] == target
                  return middle; // 数组中找到目标值，直接返回下标
              }
          }
  ```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

* 确定好如何寻找左右边界，利用一个bool变量将左右边界的二分查找集成在一个函数实现

* 注意答案未被赋值的特殊情况，以此确定是否正确找出边界

* 利用以下情况更新左边界：

  ```cpp
  if (nums[middle] >= target) { // 寻找左边界，nums[middle] == target的时候更新right
                  right = middle - 1;
                  leftBorder = right;
              } 
  ```

  更新右边界反之：

  ```cpp
  if (nums[middle] > target) {
                  right = middle - 1;
              } else { // 寻找右边界，nums[middle] == target的时候更新left
                  left = middle + 1;
                  rightBorder = left;
              }
  ```

   **此处的左右边界均为不包含target的下标！！！**

# 双指针

## [27. 移除元素](https://leetcode.cn/problems/remove-element/description/)

* 利用快慢指针处理，遍历过去把不是要移除元素的快指针所在的元素赋值给慢指针，然后慢指针自增。

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

* 快指针比慢指针多走n+1步，然后共同移动至快指针到达null。此时慢指针在倒数第N个节点前一个节点。

## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

* 利用快慢指针一前一后，不断调换next的方向，迭代整个链表后实现反转

## [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

* 利用快慢指针，快指针一次走两步。相遇则说明有环。然后利用数学原理推导入环位置。
* 一个从头节点出发，一个从相遇节点出发，他们二者同时移动，相遇节点即为环入口节点位置。

## [15. 三数之和](https://leetcode.cn/problems/3sum/description/)

* 利用双指针+排序解题。首先排序，然后固定一个`i`进行遍历，然后对每个遍历的`i`进行`left`和`right`的判断，和小了就右移left，大了左移right。对`i`去重体现在遍历时候若是和前一个数相同跳过该轮，`left`和`right`的去重在判断到为0的时候，在两个指针往里收缩的时候，判断收缩后的数字是否仍是相同的，是的话多收缩一格。

## [18. 四数之和](https://leetcode.cn/problems/4sum/description/)

* 三数之和升级版，多套一层循环
* target不为0，只能根据target和遍历到的元素都大于0的情况下进行剪枝

## [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

* **很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

  > 从前到后的时间复杂度是$O(n^2)$

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

* 先去除整个字符串中的多余空格：使用双指针法，`fastIndex`只选取非空格位置，若不是第一个单词，要自动在slow处增添空格
* 然后反转整个字符串
* 以空格和字符串的结尾为边界，对每个单词进行反转

# 字符串

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

* 先反转整个字符串，然后分别反转两部分字符串

## KMP匹配算法

* `next`前缀表数组中存储的是最长的相同先后缀长度，用于表示可以重复利用的已匹配部分的长度。

  > 我的理解：
  >
  > `aabaaf`的前缀表是[0 1 0 1 2 0]
  >
  > 如果文本串是`aabaabaaf`，则文本匹配到第二个b的时候模板串是f，此时失配，如果是普通算法就要从头开始进行模板串匹配，但是**前缀表记录了后缀和前缀相同部分的最大长度，所以可以重复利用这个长度，让模板串从这个长度之后的第一个开始继续匹配**，此处即重复利用了`aa`从模板串的`b`继续进行匹配。
  >
  > 核心思想：**把失配位置前面的匹配字符串的后缀 当作后续匹配的前缀来用**

### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

# 哈希表

关键词：重复出现（一般为隐含条件，重复出现说明无限循环之类的），不重复集合



# 栈和队列

## 单调队列

* 队列里面有序，但是队头pop出来的元素不一定真的是队头元素，因为真的队头可能已经排没了。

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

* 创建单调队列，限定pop和push

  `pop(value)`：当且仅当单调队列头部，即当前窗口最大值正好是被pop的那个value的时候，执行`pop_front()`

  `push(value)`：**单调队列的重点：当插入的数值大于队列尾部的数，就把单调队列尾部的数pop出来，直至到达队列头或者队列前面有比value大的数字**

* 本质：**push的时候仅考虑有机会称为最大值的数字**

## 优先级队列

* 队列变成有序队列

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

* 利用`map`对每个元素的频率进行存储
* 用`priority_queue`保存最高`k`频率的 pair，比较函数自定义

## 单调栈

* 维护栈顶到栈底递增的就是寻找数字右侧第一个比自己大的元素（因为大的都会导致需要pop元素才能入栈，对每个pop出来的元素求解距离等参数）；同理，维护栈顶到栈底递减的就是寻找自己右边第一个比自己小的元素。

### [739. 每日温度 ](https://leetcode.cn/problems/daily-temperatures/)

* 维护一个栈顶到栈底的递增单调栈，栈内元素是索引，只有最新温度高于栈顶才pop元素出来进行答案元组赋值。其他时候都pop新的索引进去。

### [496. 下一个更大元素 I ](https://leetcode.cn/problems/next-greater-element-i/)

* 和上题同理，先构造一个单调栈来记录每个数字对应的下一个最大元素，只不过这次记录的是元素本身值而非下标，然后把`nums1`中的元素直接根据`map`寻找其在`nums2`的下一个最大元素值

### [503. 下一个更大元素 II）](https://leetcode.cn/problems/next-greater-element-ii/)

* **关键小妙招：题目中相对于每日温度唯一的区别是改成循环数组了，我们可以通过遍历两倍的长度来实现**

### [42. 接雨水 ](https://leetcode.cn/problems/trapping-rain-water/)

**面试经典常青藤！**

1. 双指针法

   **按列算雨水**，寻找当前位置左右高于本节点柱子高度的第一根柱子。两个柱子的较小值减去本柱子高度，即为该列的雨水数量。

   直接每次遍历寻找复杂度为$O(n^2)$，所以需要用空间换时间，上数组保存每个位置左右第一个高于本柱子高度的柱子，分别从最左边和最右边迭代赋值。

2. 单调栈法

   **按行算雨水**，维护一个栈顶到栈底递增的单调栈，当出现大于栈顶元素的柱子时，说明出现了凹槽。此时栈顶是凹槽底部，栈顶下一个元素是左侧柱子，待插入元素是右侧柱子，计算高度`h = min(left, right) - height[i]`然后计算宽度为左右柱子的索引差**减一**

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

* 改找左右侧第一个小于本柱子高度的柱子的**下标**
* 用双指针的话可以利用之前构造好的数组进行跳步遍历
* 用单调栈则维护一个栈顶到栈底递减的栈，寻找到左右第一个小于本柱子的位置，**矩形是以本柱子为最小高度的矩形**

# 二叉树

* 满二叉树：树中只有**度数为0和度数为2**的结点，且**度为0的结点在同一层上**

  <img src="笔记图片/image-20230306204044016.png" alt="image-20230306204044016" style="zoom:25%;" />

* 完全二叉树：**除了最后一层可能没填满**，其余每层节点数都达到最大值，并且**最下面一层结点都集中在该层最左边的若干位置**

<img src="笔记图片/image-20230306204027718.png" alt="image-20230306204027718" style="zoom:67%;" />

## 二叉搜索树

* 有数值的二叉树，**二叉搜索树是一个有序树**
* 平衡二叉搜索树：左右子树高度差不超过1

> 红黑树实现容器  VS  哈希表实现容器
>
> set、map、multimap、multiset的底层实现是**平衡二叉树**，所以查找的时间复杂度为$O(logn)$，由于红黑树的平衡性，不会出现最坏情况
>
> unordered set、unordered map的底层实现是**哈希表**，查找时间复杂度是$O(1)$，最坏情况发生很多哈希冲突则时间复杂度变为$O(n)$，且在元素比较少的时候，用哈希表的容器可能比较浪费空间

## 二叉树遍历

迭代法

* 前序遍历：访问结点和处理结点顺序一致

  ```C++
  vector<int> preorderTraversal(TreeNode* root) {
          vector<int> res;
          stack<TreeNode *> st;
          if(root == nullptr)
              return res;
          st.push(root);
          while(!st.empty()){
              TreeNode *t = st.top();
              st.pop();
              res.push_back(t->val);
              if(t->right)
                  st.push(t->right);
              if(t->left)
                  st.push(t->left);
          }
          return res;
      }
  ```

* 中序遍历：访问结点和处理结点不一致

* 后序遍历：把前序遍历的顺序换成中右左，然后**反转结果数组**

  ```c++
  vector<int> inorderTraversal(TreeNode* root) {
          vector<int> res;
          stack<TreeNode *> st;
          TreeNode *cur = root;
          while(!st.empty() || cur != nullptr){
              if(cur != nullptr){
                  st.push(cur);
                  cur = cur -> left;
              }else{
                  cur = st.top();
                  st.pop();
                  res.push_back(cur->val);
                  cur = cur->right;
              }
          }
          return res;
      }
  ```

  ```c++
  vector<int> postorderTraversal(TreeNode* root) {
          vector<int> res;
          stack<TreeNode *> st;
          TreeNode *cur = root;
          if(root == nullptr)
              return res;
          st.push(root);
          while(!st.empty()){
              cur = st.top();
              st.pop();
              res.push_back(cur->val);
              if(cur->left)
                  st.push(cur->left);
              if(cur->right)
                  st.push(cur->right);
          }
          reverse(res.begin(), res.end());
          return res;
      }
  ```

* 层序遍历：利用队列的先进先出来遍历，**每层的size要提前测量固定**

递归法

* 层序遍历：

  ```c++
  void order(TreeNode* cur, vector<vector<int>>& result, int depth)
      {
          if (cur == nullptr) return;
          if (result.size() == depth) result.push_back(vector<int>());
          result[depth].push_back(cur->val);
          order(cur->left, result, depth + 1);
          order(cur->right, result, depth + 1);
      }
      vector<vector<int>> levelOrder(TreeNode* root) {
          vector<vector<int>> result;
          int depth = 0;
          order(root, result, depth);
          return result;
      }
  ```

  
