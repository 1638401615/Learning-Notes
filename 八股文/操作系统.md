* 操作系统四大特征：**并发，共享，虚拟，异步（不确定性）**

* 进程是进行程序**资源分配的最小单位**

* 进程崩溃，在保护模式下不会对其他进程产生影响；线程崩溃，整个进程崩溃，所以多进程比多线程健壮

* 进程切换消耗资源大，频繁切换使用线程

*  ⼀个进程可以执⾏⼀个或⼏个程序，同⼀个程序可由⼏个进程执⾏；

  > 如何理解？

* 死锁产生的四个必要条件：

  * 互斥
  * 不可剥夺
  * 请求和保持（占有且等待）
  * 循环等待（环路条件）
  
* `chmod`：控制文件权限 `-twxrwxrwx`九个权限三个一组。每种身份`owner/group/others`各自三个权限每个权限的分数是累加的

  | r    | w    | d    |
  | ---- | ---- | ---- |
  | 4    | 2    | 1    |

  eg: `chmod [-R] 770 abc.cpp` 其中`-R`表示进行递归，即连同子目录下的所有文件都会变更

* 符号链接：文件包含另一个文件的路径名

  硬链接：一个文件的多个文件名

  > 软连接可以连接不存在的**文件或者目录**，硬链接只能连接已存在的**文件**

* 缺页中断 vs 中断

  同：保护现场，进入中断处理程序，恢复现场，继续执行

  异：一条指令执行期间可以产生**多次缺页中断**，缺页中断返回的是执行**产生中断的那条指令**，一般中断返回的下一条指令



* **malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

​    **用户空间**：

​    （1）**代码段.text：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

​    （2）**数据段.data：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

​    （3）**BSS 段.bss**：存放程序中未初始化的全局变量和静态变量的一块内存区域。

​    （4）可执行程序在运行时又会多出两个区域：**堆区和栈区**。

​        **堆区：动态申请内存用**。堆从低地址向高地址增长。

​        **栈区：**存储**局部变量、函数参数值**。栈从高地址向低地址增长。是一块连续的空间。

​    （5）最后还有一个**共享区**，位于堆和栈之间。

​    **内核空间**：DMA区、常规区、高位区。

* 管道和消息队列都能用于进程的通信和同步，但主要是用于通信

  管道适用于**父子进程**需要**快速传递数据**的场景，消息队列适合**不相关进程**之间需要传递**大量复杂数据**的场景。

* 无名管道只能用于有**亲缘关系**的进程之间的通信，命名管道允许无亲缘关系进程间的通信。
* **管道本质是一种文件**





## 进程 vs 线程 vs 协程

进程

* 操作系统**资源分配的基本单位**，有自己的虚拟地址空间，分为用户空间和内核空间

线程

* 操作系统能够进行**运算调度的最小单位**，进程的实际运作单位，进程中的一条执行路径，线程共享进程资源（**虚拟内存和全局变量**），但有自己**本地的调用栈、寄存器环境和线程本地存储**等信息

协程

* **用户态的轻量级线程**，**程序员控制切换和调度**，协程可以在一个线程中执行多个任务，通过**协作而不是抢占来进行切换**，**避免了系统调用和上下文切换的开销**。协程适合用于**高并发、低延迟**的场景，如网络爬虫和网络请求。

主要区别

* 切换开销：进程切换最大，涉及用户态和内核态的切换，线程切换次之，涉及寄存器和栈的保存和恢复（线程上下文切换），协程最小，只涉及到程序计数器和栈指针的变化。

  > 进程和线程的上下文切换都需要陷入内核态，协程不用，为啥？
  >
  > * 陷入内核态的一般是**页表、TLB刷新、切换虚拟内存、全局变量、内核栈**等资源的时候才需要
  > * 协程上下文切换只涉及**基本的CPU上下文切换**，即保存和恢复CPU寄存器的状态，不需要陷入内核态。
  >
  > 进程和线程切换的区别？
  >
  > * 进程要**切换页表全局目录、刷新TLB、保存和恢复内核栈**，这些线程都是共享的
  > * 线程还要保存和恢复**线程私有数据、寄存器**等不共享的数据（内核态），还有用户栈的切换（用户态）。
  > * 以上说的都是**同一进程下的不同线程切换**，不同进程的线程切换要先去切换进程
  >
  > 什么是CPU上下文？
  >
  > * **CPU寄存器和程序计数器**

* 调度方式：进程和线程由操作系统调度，可能被抢占式地中断执行，协程由程序员负责调度，只在合适的时候主动让出执行权。

* 资源分配：进程是资源分配基本单位
* 内存空间：进程有独立虚拟地址空间，线程共享进程的，协程共享线程的。

## Page Cache

> page cache vs 匿名页
>
> * 匿名页是进程里面的堆、栈等，用于管理进程私有内存。他不对应磁盘上的任何块，依靠swap来保存和恢复。
> * page cache是用与加速文件系统读写的数据结构。它缓存了磁盘上常用的文件数据，并将它们映射到内存中的页面中，这样可以提高文件系统的读写性能。
>
> 进程的虚拟地址空间包括了代码段、数据段、堆、栈和内存映射等区域，其中**代码段和数据段是文件页**，**堆、栈和部分内存映射是匿名页**。匿名页只是进程虚拟地址空间的一部分。

> page cache VS buffer cache
>
> * **Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。**
> * 页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；
> * 块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。
>
> Page Cache 与 buffer cache 的**共同目的都是加速数据 I/O**：
>
> * Page cache主要用于文件系统的读写操作，而buffer cache主要用于块设备的读写操作。

预读机制：多申请几个page，把附近磁盘块的数据都加载到内存。

当前 Linux 下以两种方式实现文件一致性：

1. **Write Through（写穿）**：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；
2. **Write back（写回）**：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；

* write through以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失；
* write back 在系统发生宕机的时候会数据丢失，但是**程序挂了**，page cache中的数据操作系统还是会确保落盘。

## 进程通信

* 进程地址空间独立，但是**内核空间共享**，所以进程通信必须通过内核

### 管道

**所谓的管道，就是内核里面的一串缓存**，一端写入`(f[1])`，一端读取`(f[0])`

* 一般用fork创建子进程来实现管道进程间通信

  为了避免混乱，规定：

  - 父进程关闭读取的 fd[0]，只保留写入的 fd[1]；
  - 子进程关闭写入的 fd[1]，只保留读取的 fd[0]；

* **对于匿名管道，它的通信范围是存在父子关系的进程**，**对于命名管道，它可以在不相关的进程间也能相互通信**

* 管道通信遵循**先进先出**

### 消息队列

**消息队列是保存在内核中的消息链表**

不足：

1. 通信不及时
2. 附件大小有限制

* **消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**

* 消息队列不适合比较大数据的传输

### 共享内存

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**

> 用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。
>
> 为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。

### 信号量

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。

### 信号

**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**

信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。

**1.执行默认操作**。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。

**2.捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。

**3.忽略信号**。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，它们用于在任何时候中断或结束某一进程。

### Socket

**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**

TCP Socket编程模型：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/12-TCP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img" style="zoom: 50%;" />

UDP：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/13-UDP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg" alt="img" style="zoom:50%;" />

同一台主机上的进程间通信：

本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是**绑定一个本地文件**，这也就是它们之间的最大区别。

## 多线程冲突

线程之间是可以**共享进程的资源**，比如**代码段、堆空间、数据段、打开的文件**等资源，但每个线程都有**自己独立的栈空间**。

>同步与互斥是两种不同的概念：
>
>- 同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」等；
>- 互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」；

* 锁和信号量都能实现互斥，同步还得信号量来

忙等待锁（自旋锁）和无等待锁

* 当获取不到锁时，线程就会一直 while 循环，不做任何事情，所以就被称为「忙等待锁」，也被称为**自旋锁（\*spin lock\*）**。

* 无等待锁顾明思议就是获取不到锁的时候，不用自旋。既然不想自旋，那当没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行。

### 生产者-消费者问题

生产者-消费者问题描述：

- **生产者**在生成数据后，放在一个缓冲区中；
- **消费者**从缓冲区取出数据处理；
- 任何时刻，**只能有一个**生产者或消费者可以访问缓冲区；



总共需要三个信号量满足该问题：

1. 互斥访问缓冲区的信号量
2. 资源信号量 `fullBuffers`：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
3. 资源信号量 `emptyBuffers`：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；

### 哲学家进食问题

两种充分利用资源且避免死锁的方式

1. 奇数位先左后右，偶数位反之。
2. 一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。

不充分利用资源但是避免死锁：

1. 加锁去同时获取左右叉子。

### 读者-写者问题

* 用flag公平获取读写机会。
* 读者写者互斥访问，可以读读，但是只能一个写者访问临界区

### 避免死锁

* 有序资源分配

## 锁

* 基本的两种锁：**互斥锁和自旋锁**，其他锁都是基于这两种锁实现的

* **互斥锁、自旋锁、读写锁都属于悲观锁**，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。
* 乐观锁不加锁，冲突了才要求修改。Git就用了乐观锁的思想。适用于冲突概率低的。
