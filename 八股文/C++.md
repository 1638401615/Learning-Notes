* 智能指针的作用：帮助管理指针，避免函数结束忘记释放申请的空间，造成内存泄漏。因为智能指针是个类，超出类的作用域类会自动调用析构函数释放资源。

* C++三大特性：**封装、继承、多态**

* **封装本质是一种管理**：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互

* **继承是类层次的服用**

  继承中只要**函数名相同**，就构成隐藏（哪怕函数参数不同），和重构不一样

  菱形基础解决方法：虚拟继承

* 多态：**不同继承关系**的类对象，去**调用同一函数**，产生了**不同的行为**

  在继承中要构成多态还有两个条件：

  1.  必须通过**基类的指针或者引用**调用虚函数
  2.  被调用的函数必须是**虚函数**，且派生类必须对基类的虚函数进行**重写**

### 重写（覆盖） vs 重载 vs 重定义（隐藏）

* 重载：**一个类（作用域）里面**多个同名函数，参数不同，属于**编译时多态**

* 重写：

  * 两个函数分别在**基类和派生类**作用域，**函数名/返回值/参数 都必须相同**（协变除外）

    >协变(基类与派生类虚函数返回值类型不同)：
    >派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变。

    1. 必须通过**基类的指针或者引用**调用虚函数
    2. 被调用的函数必须是**虚函数**，且派生类必须对基类的虚函数进行重写

  * 两个函数必须是**虚函数**

  * **运行时多态**

  * 底层实现：

    * 每个有虚函数的类都隐含一个成员变量：虚表指针，指向一个一维的虚函数表。虚表和类一一对应，虚表指针和对象一一对应。

    - 虚表（vtbl）是一个存储了该类所有虚函数地址的数组，它在编译时就被创建好了。
    - 当一个类继承另一个类，同时会继承虚表，重写某些虚函数的时候会把原来父类虚函数的地址给覆盖掉
    - 当用一个基类指针指向一个派生类对象时，调用虚函数时，程序会根据指针所指向**对象的实际类型**，通过其**虚表指针**找到对应的**虚表**，并从中取出**正确的虚函数地址**来调用。

* 重定义：
  * 两个函数分别在基类和派生类作用域，函数名相同
  * **两个基类和派生类同名函数不构成重写就构成重定义**



* 抽象类：**包含纯虚函数（虚函数后面加`=0`）的类**，不能实例化出对象，也叫**接口类**，派生类要实例化必须重写纯虚函数，不然子类还是抽象类

### 虚函数表

* 一个含有虚函数的类中都至少都有一个**虚函数表指针**，因为虚函数的地址要被放到虚函数表中，虚函数表也简称虚表。

* 派生类的虚表生成：

  a.先将基类中的虚表内容拷贝一份到派生类虚表中 

  b.如果派生类**重写**了基类中某个**虚函数**，用派生类自己的虚函数**覆盖虚表**中基类的虚函数 

  c.派生类自己**新增**加的**虚函数**按其在派生类中的声明次序**增加到派生类虚表**的最后。
  
* 虚表在编译阶段生成，虚函数表里面的内容在创建对象的时候写入

### 堆、栈、静态存储区

动态存储区：

* 堆：存放通过 **`new` 算符**分配得到的空间
* 栈：存放函数的返回地址、参数和**局部变量**

静态存储区：

* 数据段
  * 只读数据段`.rodata`：不会被更改的`const`变量和常用文字常量，一般放在`.data`或者`.text`中
  * 已初始化的读写数据段`.data`：已初始化的全局变量和**静态局部变量**
  * 未初始化段`.bss`：**未初始化或者初始化为0**的全局变量和静态局部变量
* 代码段`.text`

两个抽象概念：

**常量存储区（一般存在只读数据段中）**，这是一块比较特殊的存储区，里面存放的是常量，不允许修改

**自由存储区（一般都用堆存，是抽象概念）**，就是那些由**malloc等分配的内存块**，和堆是十分相似的，不过是用free来结束自己的生命。

> 初始化为0的全局变量在哪里？
>
> BSS段通常是指用来存放程序中**未初始化的或者初始化为0的全局变量和静态变量**的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

* 作用域：类，局部，全局，语句，命名空间，文件作用域

  全局变量可以用`extern`声明来在其他文件使用，静态全局变量只能在本文件使用

> 堆 vs 栈
>
> * 堆地址低到高，栈地址高到低
>
> * 堆内存要手动申请释放，栈OS自动申请释放
>
> * 堆频繁malloc和free会产生内存碎片，栈先进后出，不会
>
> * 堆分配效率低，栈分配效率高
>
>   原因：栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。

### 内联函数 vs 宏定义

* 内联函数在编译展开，宏定义在预编译展开
* 内联函数才会进行类型检查，宏定义只是文本替换
* 宏定义要依靠括号来保证运算符优先级
* 内联函数以膨胀代码为代价，减少调用开销，所以不适合**代码运行时间很久（循环）**的函数体或者**代码量很长（内存复制代码消耗大）**的函数体

### new vs malloc

* new是**操作符**、C++**关键字**，malloc是**函数**

* new操作符会调用对象的构造函数进行初始化，而malloc函数不会进行任何初始化
* malloc返回对象为`void *`，需要强制转换
* new可以重载，malloc不行
* new分配更安全、直接
* new错误抛出异常，malloc返回null

### `const`指针

* `const`加在星号前面一律是不能改变所指向的内存的值，即 `*a`不能变,eg: `int const *a`
* `const`直接在变量名前面说明无法更改变量所指向的内存，即 `a` 不能变,eg:`int *const a`

### 内存对齐

struct内存对齐规则：

1. 每个成员的偏移量是**自身大小和对齐模数中较小那个数**的整数倍，这里指的是基本成员，不是基本成员的例如结构体成员要从其内部**"最宽基本类型成员"的整数倍地址**开始存储
2. 整个结构体大小是最大结构成员大小的整数倍，不够的在后面填充字节补齐



### 移动/拷贝 构造函数

* 移动拷贝构造函数的使用必须调用`std::move`
* 移动拷贝构造函数要保证移动资源归属后，源对象必须保持**有效的、可析构的**状态，用户不能对其中的值有任何假设，要用自己再赋值。
* 移动拷贝构造减少了复制的开销，提高性能，节省内存。
* `std::move`转换为右值引用，说明这个对象马上不用了，且该对象没有其他用户

* 只有`const`的左值引用或者右值引用可以绑定到右值上

### 深/浅拷贝

* 默认浅拷贝，只复制对象的结构，不复制元素，两个对象共享一个元素
* 深拷贝是把对象的结构和元素都复制了，两个对象有各自的元素
* 深拷贝是递归的



### 构造函数调用顺序

* 父类构造函数-->成员类的对象构造函数-->自身构造函数
* 成员变量的初始化与声明顺序有关，构造函数的调用顺序是类派生列表中的顺序。



### 虚析构

* 虚析构存在的原因：保证**基类指针指向派生类**对象析构的时候能调用派生类的析构函数，释放派生类中可能分配的堆内存，**防止内存泄漏**

* 析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了

* C++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针，占用额外的内存**。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数

> 为什么没有虚构造？
>
> * 构造函数要是虚函数会被放在虚表，虚函数要通过虚表指针访问，虚表指针储存在对象的内存空间，创建对象的时候还没分配内存空间，也就没有虚表指针，也就无法调用虚函数。
> * 调用构造函数的时候还不能确定对象的真实类型，而虚函数是运行的时候根据对象实际类型进行动态绑定的。所以用虚构造创建对象的时候，不知道调用哪个构造函数了



### 模板实例化 vs 模板具体化

* 模板实例化：分为显式和隐式，前者是开发人员明确告诉模板用什么类型，后者是编译过程中用编译器来决定使用什么类型，无论显式还是隐式，都是按照模板定义实现
* 模板具体化：为了让某个特定类型提供一个和模板**不同的定义**，**针对某个特定类型的修改**



### 类继承

* 类中可以访问自己类的所有类型成员，但是类对象只能访问自己类的public成员
* 三种继承，派生类都能访问基类的`public、protected`成员，但是**只有public继承派生类对象能访问基类的public成员**，另外两种继承派生类对象不可以访问基类任何成员



### C++类能定义引用数据成员吗

c++类内可以定义引用成员变量，但要遵循以下三个规则：

1. 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
2. 构造函数的形参也必须是引用类型。
3. 不能在构造函数里初始化，必须在初始化列表中进行初始化。



### 常函数

* 常函数：类的成员函数后面加`const`，表示不会对这个类对象的非静态数据成员做任何改变，只能读取数据成员

>除此之外，在类的成员函数后面加 `const` 还有什么好处呢？
>
>那就是常量（即` const`）对象可以调用 `const `成员函数，而不能调用非`const`修饰的函数。正如非`const`类型的数据可以给`const`类型的变量赋值一样，反之则不成立。



### 虚继承解决菱形继承

* 虚继承利用**虚基表**来处理菱形继承，每个虚继承派生类都有一个虚基类指针和虚基类表，虚基类表存储的是虚基类相对直接继承类的偏移量。当访问虚基类成员时，可以通过虚基类指针找到虚基类表，然后根据偏移量定位到正确的位置。



### 顶层`const` 和底层 `const`

* 顶层`const`：对象本身是常量，如常量指针`int * const p`，不能修改指向的地址
* 底层`const`：指针所指向对象是常量，如指针常量`const int *p`，不能修改所指向的对象的内容，即`*p`不能变



### 仿函数

* 必须重载`operator()`运算符



### 不能声明为虚函数的函数

1. 普通函数（非成员函数）

   只能被重载，不能重写

2. 构造函数

   对象在构建，虚函数的运行建立在对象基础上，此时对象还没构建

3. 内联函数

   编译展开和动态联编冲突

4. 静态成员函数

   所有类共享一个，没有动态绑定必要

5. 友元函数

   C++不支持友元函数的继承



### 类模板 vs 模板类

* 类模板是模板，模板类是类
* 类模板用于生成模板类，它定义了通用的类。**模板类是类模板实例化的产物。**



### 容器

1. 顺序容器
   * vector：动态数组
   * list：双向链表，**元素存在堆中**
   * deque：双向队列
2. 关联式容器
   * map/multimap：map会根据first从小到大排序
   * set/multiset
   * map和set都是红黑树实现，区别在于map的值不作为键，键和值分开
   * set键值合一且不能被迭代器修改，set迭代器全是`const`的
3. 容器适配器
   * queue
   * stack
   * priority_queue

> 普普map/multimap/set/multiset和unordered map/set/multimap/multiset的区别？
>
> * 前者底层实现是**红黑树**，是平衡二叉树的一种，插入、查询、删除都是`O(logn)`时间复杂度
> * 后者底层实现都是**哈希表**，理想情况下能在常数时间内完成插入、查询、删除，但是如果哈希冲突过多，可能导致最坏情况`O(n)`复杂度

> accumulate 中lambda表达式用法
>
> ```
> //执行最多次任务的任务种类
>         int max_count = accumulate(count.begin(), count.end(), 0, [&](int acc, const auto &a){
>             return acc + (a.second == max_exec);
>         });
> ```
>
> 这段代码是accumulate的四个参数用法，第三个参数表示累加初始值，第四个参数规定了累加的方式。
>
> 第四个参数接收两个参数，第一个参数是累加的结果，第二个参数是当前元素的值。累加结果依靠lambda表达式中的return语句更新。
>
> 中括号代表捕获列表：
>
> 捕获列表中的符号有`[]`。其中，`[]`表示不捕获任何变量，`[=]`表示以值的方式捕获所有变量，`[&]`表示以引用的方式捕获所有变量，而`[a,&b]`表示以值的方式捕获变量a，以引用的方式捕获变量b。

### 迭代器失效

* 序列式容器，`erase`操作后指向删除节点和之后的全部迭代器都失效，后边每个元素都往前移动一位，可以利用**erase返回下一个有效的迭代器**来解决，`push_back()`会导致end操作返回的迭代器失效

* 关联式容器是用红黑树实现的底层，`erase`之后仅会使当前的迭代器失效，所以在调用之前**记录下一个元素迭代器**即可。

* 链表式容器如`list`，插入删除一个结点不会对别的结点造成影响，用**递增当前iterator**或者**erase返回下一个有效iterator**的方法就能解决

> 有了指针为什么还要迭代器？
>
> * 迭代器可以让我们在**不知道对象内部表示情况下，按照一定顺序访问聚合对象中各个元素**



### resize vs reserve

* resize：既分配了空间也创建了对象，扩大的时候size和capacity都改
* reserve：只是预留空间，并不是真正创建对象，只修改capacity不改size
* vector的自动扩容在`g++`中是自动扩容一倍，但是扩容很慢，所以最好提前预估分配，减少自动扩容



### emplace_back  VS push_back

* push_back要构造临时对象，再拷贝到容器末尾，emplace_back直接在容器末尾构造对象，省去拷贝过程



### 智能指针

* `unique_ptr`：严格实现独占式，不允许赋值给另一个，除非本身是临时右值或者被转换为右值
* `shared_ptr`：共享式拥有，多个指针指向相同对象
* `weak_ptr`：**不控制对象生命周期的智能指针**，指向一个`shared_ptr`管理的对象，不增加引用计数，只提供访问管理对象的手段(需要转换成`shared_ptr`先)，用于解决**`shared_ptr`相互引用的死锁问题**

**注意**：我们不能通过`weak_ptr`直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，`pa->pb*->print()`; 英文`pb*`是一个`weak_ptr`，应该先把它转化为`shared_ptr`，如：`shared_ptr p = pa->pb_.lock(); p->print();`   



### C++11 四种类型转换

* `const_cast`：把`const`转换为`非const`
* `static_cast`：**最常用，可以用于各种隐式转换**，能用于类向上转换，向下也行但是不安全

* `dynamic_cast`：只能用于**含有虚函数**的类转换，向上子转父，向下父转子，向下可能出现非法内存访问问题

* `reinterpret_cast`：可以做任何类型的转换，不过不对转换结果保证，容易出问题。



### auto和`const`

* 当类型不为引用，auto的推导结果不保留`const`，除非自己加上
* 类型是引用的时候，auto的推导结果保留表达式的`const`



### 可变参数模板

* 模板参数包
* 函数参数包
* 展开参数包
* 递归

C++11 中引入了可变参数模板（variadic template）的新特性，可以让函数和类模板接受任意数量和任意类型的参数。可变参数模板的语法如下：

```
c++Copy codetemplate <typename... Ts> void foo(Ts... args) {
    // ...
}
```

其中，`Ts` 是一个模板参数包（template parameter pack），`args` 是一个函数参数包（function parameter pack），`Ts...` 表示可以接受任意数量的模板参数，`args...` 表示可以接受任意数量的函数参数。

在函数内部，可以使用类似于展开包（unpacking）的方式来访问参数包中的每个参数：

```
c++Copy codetemplate <typename... Ts> void foo(Ts... args) {
    int arr[] = {args...}; // 将参数包中的参数放到数组中
    // ...
}
```

可变参数模板还可以与递归展开（recursive unpacking）结合使用，用于处理参数包中的每个元素，例如：

```
c++Copy codetemplate <typename T>
void print(const T& t) {
    std::cout << t << std::endl;
}

template <typename T, typename... Ts>
void print(const T& t, const Ts&... args) {
    std::cout << t << ", ";
    print(args...);
}
```

上述代码定义了一个递归函数模板 `print`，可以接受任意数量和任意类型的参数，并逐个打印出来。在第一个模板参数 `T` 中，我们处理了参数包中的第一个元素，然后通过递归调用 `print(args...)` 处理剩余的元素，实现了对参数包中所有参数的遍历和打印。



## C++14特性

* auto功能扩展到变量、lambda函数、函数返回值中了



## C++17特性

* 结构化绑定，可以直接**快速解包tuple元组、数组、结构体、全是public数据成员且没有static数据的类**

  eg：

  ```c++
  auto tup = make_tuple("123", 12, 7.0);
  c++11:
  string str;
  int i;
  double d;
  std::tie(str, i, d) = tup;
  
  C++17一行搞定
  auto [x,y,z] = tup;
  
  
  double myArray[3] = { 1.0, 2.0, 3.0 };  
  auto [a, b, c] = myArray;
  auto& [ra, rb, rc] = myArray;
  struct S { int x1 : 2; double y1; };
  S f();
  const auto [ x, y ] = f; //备注1：
  ```

* `std:variant`：tuple相当于struct的延申、variant相当于union的延申

* 用于可变参数模板的**折叠表达式**：

  C++11实现多数累加器：

  ```c++
  template<typename T>
  auto myAdd(const T& a,const T& b){
      return a + b;
  }
  template<typename T, typename... RestT>
  auto myAdd(const T& a, const RestT&... restArgs){
      return a + myAdd(restArgs...);
  }
  ```

  C++17:

  ```c++
  template<typename ...Args> 
  auto myAddEx(const Args& ...args) { 
      return (args + ...); //编译器会这样干：1+(2+(3+(4)))
      或者
      return (... + args); //编译器会这样干：((1+2)+3)+4
      对于加法上述两种表达是等效的，但是减法就不是了。另外，括号是不能省略的
  }
  cout<<myAddEx(1,2,3,4)<<endl;
  ```

* `if constexpr`:允许函数在**编译期间**根据条件选择执行不同的代码分支，避免运行时开销

* 类模板也允许**实参推演**了
* `if/switch`语句内支持初始化
* inline可以修饰变量了，即内联变量