## 组织结构：柱面组

FFS 将磁盘划分为一些分组，称为柱面组（cylinder group， 而一些现代文件系统，如 Linux ext2 和 ext3，就称它们为块组，即 block group）

创建新FFS文件时，会对柱面组进行至少**四次写入**：

1. 新分配的inode
2. inode位图
3. 数据位图
4. 数据块

还要把文件放入文件系统层次结构中，更新父目录，添加条目，更新父目录inode，反映目录新长度和更新时间字段

## 如何分配文件和目录

* 目录的放置：找到分配数量少的柱面组（因为我们希望跨组平衡目录）和大量的自由 inode/数据块（因为我们希望随后能够分配一堆文件），并将目录数据 和 inode 放在该分组中。

* 文件的放置：

  1. 首先，它确保（在一般情况下）将文件的数据块分配到与其 inode 相同的组中，从而防止 inode 和数据之间的长时间寻道（如在老文件系统中）。
  2. 它将位于同一目录中的所有文件，放在它们所在目录的柱面组中

* **大文件的放置**：在将一定数量的块分配到第一个块组（例如， 12 个块，或 inode 中可用的直接指针的数量）之后，FFS 将文件的下一个“大”块（即第一 个间接块指向的那些部分）放在另一个块组中（可能因为它的利用率低而选择）。然后，文 件的下一个块放在另一个不同的块组中，依此类推。

  为了改善分散文件的性能损耗，我们可以合理分配大块大小，使得大部分时间花在传输数据，少部分时间用于寻道。

  每次开销做更多的工作，从而减少开销，称之为**摊销**

* 小文件的放置：引入512字节的**子块**，存在子块里面，直到达到4KB，存到4KB块，释放子块

  > 如何解决这个过程的额外工作（特别是执行复制的大量I/O）导致的效率低下？
  >
  > FFS 通常通过修改 libc 库来避免这种异常行为。该库将缓冲写入，然后以 4KB 块的形式将它们发送到文件系统，从而在大多数情况下完全避免子块的特殊情况

## FFS的其他优化

1. 使用不同布局解决顺序读取问题
2. 在内部读取整个磁道并将其缓冲在内部磁盘缓存中，在对轨道的后续读取中，磁盘就从其高速缓存中返回所需数据。
3. FFS是第一个允许长文件名的系统之一
4. 原子化的rename（）