锁的存在确保了临界区一次只能进去一个线程，使得系统调度可控。

细粒度方案：一个临界区有多个锁，锁用于保护不同的数据和结构

* 如何评价锁？
  1. 锁能否提供互斥
  2. 公平性
  3. 性能

## 互斥解决方案

1. 控制中断

   缺点：允许调用线程执行特权操作打开关闭中断，程序可能独占处理器；

   ​			不支持多处理器；

   ​			关闭中断导致中断丢失；

   ​			效率低下。
   
2. 测试并设置指令（原子交换）test（旧的锁值） and set（新的锁值）

   自旋锁（spin lock）：一直自旋，利用CPU周期，直至锁可用。所以在单处理器上需要抢占式处理器（不断通过时钟中断一个线程，运行其他线程）才能使用。

> 自旋锁评价：
>
> 1. 能提供互斥
>
> 2. 不保证公平
>
> 3. 单CPU开销大，多CPU性能好（线程数大致等于CPU数）

3. 比较并交换 compare and swap

4. 链接的加载和条件式存储指令

   链接的加载：内存中取出值存入寄存器

   条件式存储：上一次加载的地址在期间没有更新过，更新其值，指令返回成功标志。

5. 获取并增加 fetch and add

   利用该指令实现ticket锁：每个想要获取锁的线程在lock的时候都对一个ticket值进行获取并增加操作，返回值作为myturn，unlock则是增加turn，当某个线程turn == myturn时，轮到该线程进入临界区。

   **ticket锁保证了所有线程都能够进入临界区**

## 如何避免不必要自旋

1. 在自旋的时候，放弃CPU

2. 使用队列：休眠代替自旋

   可能发生唤醒/等待竞争（wakeup/waiting race），需要：

   法一：增加setpark()指示即将park，即使另一个线程被调度且unpark，后续park仍能直接返回，而不是一直睡眠。

   法二：将guard转入内核，内核能采取预防措施，保证原子地释放锁，把运行线程移出队列

两阶段锁：先自选一段时间，第二段时间选择休眠，直至锁可用