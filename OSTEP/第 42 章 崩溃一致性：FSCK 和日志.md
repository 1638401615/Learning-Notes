### 崩溃一致性问题

* 崩溃一致性问题：如果在一次写入完成后系统崩溃或断电，则磁盘上的结构将处于不一致（inconsistent）的状态

### 解决方案1：文件系统检查程序fsck

fsck基本总结：

* 超级块：对超级块进行健全性检查，例如确保文件系统大小大于分配块数
* 空闲块：扫描inode，间接块，双重间接块，生成正确分配位图。**若是inode和位图存在不一致，信任inode内信息**

* inode状态：检查inode是否损坏，若是字段存在问题则清除，inode位图相应更新
* indoe连接：扫描目录树，构建链接计数，若是和inode中的链接计数不匹配，修复inode中计数。如果发现已分配的 inode 但没有目录引用它，则会将其移动到 lost + found 目录
* 重复：两个不同inode指向同一个块，清除/复制指向块
* 坏块：扫描指针列表，发现如果指针显然指向超出其有 效范围的某个指针，则从inode或者间接块中删除它
* 目录检查：对目录进行完整性检查，并确保整个层次结构中没有目录引用超过一次

fsck问题：太慢了，磁盘一大，扫描就要很久

### 解决方案 2：日志（或预写日志）

* 在覆写结构之前，首先写下一点小注记（在磁盘上的其 他地方，在一个众所周知的位置），描述你将要做的事情。写下这个注记就是“预写”部分， 我们把它写入一个结构，并组织成“日志”。因此，就有了预写日志。

* #### 数据日志

  一旦这个事务安全地存在于磁盘上，我们就可以覆写文件系统中的旧结构了。这个过程称为**加检查点（checkpointing）**。

  1．日志写入：将事务（包括事务开始块，所有即将写入的数据和元数据更新以及事务 结束块）写入日志，等待这些写入完成。 

  2．加检查点：将待处理的元数据和数据更新写入文件系统中的最终位置。

> * 强制写入磁盘顺序：发出写入屏障，这样的屏障，当它完成时，能确保在屏障之前发出的所有写入，先于在屏障 之后发出的所有写入到达磁盘。
>
> * 优化日志写入：将事务写 入日志时，在开始和结束块中包含日志内容的校验和。这样做可以使文件系统立即写入整个事务，而不 会产生等待。如果在恢复期间，文件系统发现计算的校验和与事务中存储的校验和不匹配，则可以断定在写入事务期间发生了崩溃，从而丢弃了文件系统更新。
>
> * 此过程的一个重要方面是磁盘提供的**原子性保证**。事实证明，磁盘保证任何 512 字节 写入都会发生或不发生（永远不会半写）。因此，为了确保 TxE 的写入是原子的，应该使它成为一个 512 字节的块

* 为了避免写入日志时崩溃导致的问题，更新文件系统协议：

  1．日志写入：将事务的内容（包括 TxB、元数据和数据）写入日志，等待这些写入完成。

  2．日志提交：将事务提交块（包括 TxE）写入日志，等待写完成，事务被认为已提交 （committed）。 

  3．加检查点：将更新内容（元数据和数据）写入其最终的磁盘位置

* 恢复

  1. 崩溃发生在写入日志之前：跳过待执行的更新
  2. 提交日志之后加检查点之前崩溃：文件系统再次尝试将事务中的块写入它们最终的磁盘位置

* 批处理日志更新：缓存更新。

* 使日志有限

  在上述文件系统协议增添一个：

  4．释放：一段时间后，通过更新日志超级块，在日志中标记该事务为空闲。

* #### 元数据日志

  和数据日志相比，它不将用户数据写入日志，提高了性能。同时通过强制先写入数据，文件系统可以保证指针永远不会指向垃圾。

  具体协议如下：

  1．数据写入：将数据写入最终位置，等待完成（等待是可选的，详见下文）。 

  2．日志元数据写入：将开始块和元数据写入日志，等待写入完成。 

  3．日志提交：将事务提交块（包括 TxE）写入日志，等待写完成，现在认为事务（包 括数据）已提交（committed）。 

  4．加检查点元数据：将元数据更新的内容写入文件系统中的最终位置。 

  5．释放：稍后，在日志超级块中将事务标记为空闲

* 块复用

  通过在日志中增添**撤销记录**，来保证系统崩溃重放日志时，此类撤销数据不被重放，从而保证已经删除的文件不会错误重放。

### 解决方案3：其他方法

1. 软更新：对文件系统的所有写入排序，以确保磁盘上的结构永远不会处于不一致的状态

2. 写时复制COW
3. 基于反向指针的一致性，例如在数据块中增添指向它的inode的反向指针
4. 乐观崩溃一致性，尽可能多向磁盘发出写入，利用事务校验和等检测不一致

总结：

**日志可将恢复时间从 O（磁盘大小的卷）减少到 O（日志大小），从而在崩溃和重新启动后大大加快恢复速度**。最常用的是**有序元数据日志**，它可以减少日志流量，同时仍然保证文件系统元数据和用户数据的合理一致性